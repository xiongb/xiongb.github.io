---
title: 二叉树遍历
date: 2020-04-08 20:16:02
tags:  "js 数据结构 算法"
---
###二叉树
    本身是有序树；
    树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2；
###二叉树性质 
    二叉树中，第 i 层最多有 2^(i-1) 个结点。
    如果二叉树的深度为 K，那么此二叉树最多有 2K-1 个结点。
    二叉树中，终端结点数（叶子结点数）为 n0，度为 2 的结点数为 n2，则 n0=n2+1。
性质 3 的计算方法为：对于一个二叉树来说，除了度为 0 的叶子结点和度为 2 的结点，剩下的就是度为 1 的结点（设为 n1），那么总结点 n=n0+n1+n2。
同时，对于每一个结点来说都是由其父结点分支表示的，假设树中分枝数为 B，那么总结点数 n=B+1。而分枝数是可以通过 n1 和 n2 表示的，即 B=n1+2n2。所以，n 用另外一种方式表示为 n=n1+2n2+1。
两种方式得到的 n 值组成一个方程组，就可以得出 n0=n2+1。

###满二叉树
    如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为满二叉树。图1即为满二叉树。
下图是本节二叉树用例图1：
    {% asset_img 211.jpg %}

满二叉树除了满足普通二叉树的性质，还具有以下性质：

    满二叉树中第 i 层的节点数为 2n-1 个。
    深度为 k 的满二叉树必有 2k-1 个节点 ，叶子数为 2k-1。
    满二叉树中不存在度为 1 的节点，每一个分支点中都两棵深度相同的子树，且叶子节点都在最底层。
    具有 n 个节点的满二叉树的深度为 log2(n+1)。


###完全二叉树
    如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。
   {% asset_img 212.jpg %}
如图 a) 所示是一棵完全二叉树，图 b) 由于最后一层的节点没有按照从左向右分布，因此只能算作是普通的二叉树。
完全二叉树除了具有普通二叉树的性质，它自身也具有一些独特的性质，比如说，n 个结点的完全二叉树的深度为 ⌊log2n⌋+1。
    ⌊log2​n⌋ 表示取小于 log2n的最大整数。例如，⌊log2^4 = 2，而 ⌊log2^5⌋ 结果也是 2。
对于任意一个完全二叉树来说，如果将含有的结点按照层次从左到右依次标号（如图 a)），对于任意一个结点 i ，完全二叉树还有以下几个结论成立：
   
    当 i>1 时，父亲结点为结点 [i/2] 。（i=1 时，表示的是根结点，无父亲结点）
    如果 2i>n（总结点的个数） ，则结点 i 肯定没有左孩子（为叶子结点）；否则其左孩子是结点 2i 。
    如果 2i+1>n ，则结点 i 肯定没有右孩子；否则右孩子是结点 2i+1 。
普通二叉树转完全二叉树的方法很简单，只需给二叉树额外添加一些节点，将其"拼凑"成完全二叉树即可。如下图所示：
   {% asset_img 213.jpg %}

###二叉树的顺序存储结构

    二叉树的存储结构有两种，分别为顺序存储和链式存储
    二叉树的顺序存储，指的是使用顺序表（数组）存储二叉树。需要注意的是，顺序存储只适用于完全二叉树。换句话说，只有完全二叉树才可以使用顺序表存储。因此，如果我们想顺序存储普通二叉树，需要提前将普通二叉树转化为完全二叉树。
###二叉树的链式存储结构
   {% asset_img 214.jpg %}
   如上图所示，此为一棵普通的二叉树，若将其采用链式存储，则只需从树的根节点开始，将各个节点及其左右孩子使用链表存储即可。因此，上图对应的链式存储结构如下图所示：
   {% asset_img 215.jpg %}
   
####由图可知，采用链式存储二叉树时，其节点结构由 3 部分构成（如下图所示）：
   
    指向左孩子节点的指针（Lchild）；
    节点存储的数据（data）；
    指向右孩子节点的指针（Rchild）；
    ````
    class Node {
        constructor(value) {
            this.value = value;
            this.left = null;
            this.right = null;
        }
    }
    ````
####二叉树先序遍历
    二叉树先序遍历的实现思想是：
    访问根节点；
    访问当前节点的左子树；
    若当前节点无左子树，则访问当前节点的右子树；
    图 1 中二叉树采用先序遍历得到的序列为：1245367
    
####二叉树中序遍历
    二叉树中序遍历的实现思想是：
    访问当前节点的左子树；
    访问根节点；
    访问当前节点的右子树；
####二叉树后序遍历
    二叉树后序遍历的实现思想是：从根节点出发，依次遍历各节点的左右子树，直到当前节点左右子树遍历完成后，才访问该节点元素。
####二叉树层次遍历(广度优先遍历 队列：先压左节点，再压右节点)
    也就是按层次的去遍历。依次遍历根节点，然后是左孩子和右孩子。所以要遍历完当前节点的所有孩子，这样才是层次遍历嘛。此时我们就不能用栈这个数据结构了，因为栈只能在栈顶操作。在这里，我们需要根据左右孩子的顺序来输出，所以就是先进先出的原则，那么我们当然就想到了队列这个数据结构。可以在rear依次插入左右孩子，在front依次读取并删除左右孩子，这样就保证了层次的输出。
    
####深度优先遍历（栈，先压右节点，再压左节点）
    也就深入的遍历，沿着每一个分支直到走到最后，然后才返回来遍历剩余的节点。二叉树不同于图，图需要标记节点是否已经访问过，因为可能会存在环，而二叉树不会出现环，所以不需要标记。那么，我们只需要一个栈空间，来压栈就好了。因为深度优先遍历，遍历了根节点后，就开始遍历左子树，所以右子树肯定最后遍历。我们利用栈的性质，先将右子树压栈，然后在对左子树压栈。此时，左子树节点是在top上的，所以可以先去遍历左子树。

