<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>链表js</title>
      <link href="/2020/04/08/%E9%93%BE%E8%A1%A8js/"/>
      <url>/2020/04/08/%E9%93%BE%E8%A1%A8js/</url>
      
        <content type="html"><![CDATA[<p>####</p><ul><li>1) 单链表反转</li><li>2) 链表中环的检测</li><li>3) 两个有序的链表合并</li><li>4) 删除链表倒数第n个结点</li><li>5) 求链表的中间结点<br>####</li></ul><pre><code>class Node {    constructor(element) {        this.element = element        this.next = null    }}class LinkedList {    constructor() {        this.head = new Node('head')    }    // 根据value查找节点     findByValue(item) {        let currentNode = this.head        while (currentNode !== null &amp;&amp; currentNode.element !== item) {            currentNode = currentNode.next        }        return currentNode === null ? -1 : currentNode    }    // 根据index查找节点     findByIndex(index) {        let currentNode = this.head        let pos = 0        while (currentNode !== null &amp;&amp; pos !== index) {            currentNode = currentNode.next            pos++        }        return currentNode === null ? -1 : currentNode    }    // 指定元素向后插入    insert(newElement, element) {        const currentNode = this.findByValue(element)        if (currentNode === -1) {            console.log('未找到插入位置')            return        }        const newNode = new Node(newElement)        newNode.next = currentNode.next        currentNode.next = newNode    }    // 查找前一个    findPrev(item) {        let currentNode = this.head        while (currentNode.next !== null &amp;&amp; currentNode.next.element !== item) {            currentNode = currentNode.next        }        if (currentNode.next === null) {            return -1        }        return currentNode    }    // 根据值删除    remove(item) {        const desNode = this.findByValue(item)        if (desNode === -1) {            console.log('未找到元素')            return        }        const prevNode = this.findPrev(item)        prevNode.next = desNode.next    }    // 遍历显示所有节点    display() {        //先检查是否为环        if(this.checkCircle()) return false        let currentNode = this.head        while (currentNode !== null) {            console.log(currentNode.element)            currentNode = currentNode.next        }    }    // 尾插法 反转单链表    reverseList() {        const root = new Node('head')        let currentNode = this.head.next        while (currentNode !== null) {            const next = currentNode.next            currentNode.next = root.next            root.next = currentNode            currentNode = next        }        this.head = root    }    //增强尾插法可读性，便于初学者理解    reverseList1(){      //head节点即哨兵，作用就是使所有链表，      // 包括空链表的头节点不为null,并使对单链表的插入、删除操作不需要区分是否为空表或是否在第一个位置进行，      // 从而与其他位置的插入、删除操作一致      //所以反转链表的时候不需要带上head节点      let currentNode=this.head.next      //第一个节点头结点让其指向null      let previousNode=null      while(currentNode!==null){        //务必先保留下一节点的指针地址        let nextNode=currentNode.next        //第一次是null        currentNode.next=previousNode        //此时将previousNode赋值为当前节点，        // 那么下次循环的时候，方便下次的currentNode指向previousNode        previousNode=currentNode        //抬走，下一个！        currentNode=nextNode      }    //最后将反转好的链表加上头节点    this.head.next=previousNode    }    // 自己一开始瞎想的。差距啊    reverseList2() {        let currentNode = this.head.next        let reverseList = new LinkedList()        const tempArr = []        if (currentNode === null || currentNode.next === null) {            console.log('节点数小于3，不反转')            return        }        while (currentNode !== null) {            tempArr.push(currentNode)            currentNode = currentNode.next        }        for (let i = tempArr.length - 1; i &gt;= 0; i--) {            const key = i === tempArr.length - 1 ? 'head' : tempArr[i + 1].element            reverseList.insert(tempArr[i].element, key)        }        reverseList.display()        return reverseList    }    // 环验证    checkCircle() {        let fast = this.head.next        let slow = this.head        while (fast !== null &amp;&amp; fast.next !== null) {            fast = fast.next.next            slow = slow.next            if (slow === fast) return true        }        return false    }    // 删除倒数第k个节点    removeByIndexFromEnd(index) {        //务必先判断是否是 环链表        if(this.checkCircle()) return false        let pos = 1        this.reverseList()        let currentNode = this.head.next        while (currentNode !== null &amp;&amp; pos &lt; index) {            currentNode = currentNode.next            pos++        }        if (currentNode === null) {            console.log('无法删除最后一个节点或者该节点不存在')            return false        }        this.remove(currentNode.element)        this.reverseList()    }    // 求中间节点    findMiddleNode() {        let fast = this.head        let slow = this.head        while (fast.next !== null &amp;&amp; fast.next.next !== null) {            fast = fast.next.next            slow = slow.next        }        console.log(slow)        return slow    }}const mergeSortedLists = (listA, listB) =&gt; {    if (!listA) {        return listB    }    if (!listB) {        return listA    }    let a = listA    let b = listB    let resultList = undefined    if (a.element &lt; b.element) {        resultList = a        a = a.next    } else {        resultList = b        b = b.next    }    let currentNode = resultList    while (a !== null &amp;&amp; b !== null) {        if (a.element &lt; b.element) {            currentNode.next = a            a = a.next        } else {            currentNode.next = b            b = b.next        }        currentNode = currentNode.next    }    if (a != null) {        currentNode.next = a    } else {        currentNode.next = b    }    return resultList}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>二分查找js版</title>
      <link href="/2020/04/08/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BEjs%E7%89%88/"/>
      <url>/2020/04/08/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BEjs%E7%89%88/</url>
      
        <content type="html"><![CDATA[<p>###数组必须有序不存在重复,查找target的位置 </p><pre><code>const biaryFind = (sortedArr, target) =&gt; {    if (sortedArr.length === 0) return -1    let low = 0    let high = sortedArr.length - 1    while (low &lt;= high) {        const mid = Math.floor((low + high) / 2)        if (target === sortedArr[mid]) {            return mid        } else if (target &lt; sortedArr[mid]) {            high = mid - 1        } else {            low = mid + 1        }    }    return -1}</code></pre><p>###查找第一个等于给定值</p><pre><code>const biaryFindFirst = (sortedArr, target) =&gt; {    if (sortedArr.length === 0) return -1    let low = 0    let high = sortedArr.length - 1    while (low &lt;= high) {        const mid = Math.floor((low + high) / 2)        if (target &lt; sortedArr[mid]) {            high = mid - 1        } else if (target &gt; sortedArr[mid]) {            low = mid + 1        } else {            if (mid === 0 || sortedArr[mid - 1] &lt; target) return mid            high = mid - 1        }    }    return -1}</code></pre><p>###查找最后一个相等的数</p><pre><code>const biaryFindLast = (sortedArr, target) =&gt; {    if (sortedArr.length === 0) return -1    let low = 0    let high = sortedArr.length - 1    while (low &lt;= high) {        const mid = Math.floor((low + high) / 2)        if (target &lt; sortedArr[mid]) {            high = mid - 1        } else if (target &gt; sortedArr[mid]) {            low = mid + 1        } else {            if (mid === sortedArr.length - 1 || sortedArr[mid + 1] &gt; target) return mid            low = mid + 1        }    }    return -1}</code></pre><p>###查找第一个大于等于给定值的元素</p><pre><code>const biaryFindFistBig = (sortedArr, target) =&gt; {    if (sortedArr.length === 0) return -1    let low = 0    let high = sortedArr.length - 1    while (low &lt;= high) {        const mid = Math.floor((low + high) / 2)        if (target &lt;= sortedArr[mid]) {            if (mid === 0 || sortedArr[mid - 1] &lt; target) return mid            high = mid - 1        } else {            low = mid + 1        }    }    return -1}</code></pre><p>###查找最后一个小于等于给定值的元素</p><pre><code>const biaryFindLastSmall = (sortedArr, target) =&gt; {    if (sortedArr.length === 0) return -1    let low = 0    let high = sortedArr.length - 1    while (low &lt;= high) {        const mid = Math.floor((low + high) / 2)        if (target &lt; sortedArr[mid]) {            high = mid - 1        } else {            if (mid === sortedArr.length - 1 || sortedArr[mid + 1] &gt;= target) return mid            low = mid + 1        }    }    return -1}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法js版</title>
      <link href="/2020/04/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95js/"/>
      <url>/2020/04/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95js/</url>
      
        <content type="html"><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><pre><code>const bubbleSort = (arr) =&gt; {    if (arr.length &lt;= 1) return    for (let i = 0; i &lt; arr.length; i++) {        let hasChange = false        for (let j = 0; j &lt; arr.length - i - 1; j++) {            if (arr[j] &gt; arr[j + 1]) {                const temp = arr[j]                arr[j] = arr[j + 1]                arr[j + 1] = temp                hasChange = true            }        }        // 如果false 说明所有元素已经到位        if (!hasChange) break    }    console.log(arr)}</code></pre><p>###插入排序</p><pre><code>const insertionSort = (arr) =&gt; {    if (arr.length &lt;= 1) return    for (let i = 1; i &lt; arr.length; i++) {        const temp = arr[i]        let j = i - 1        // 若arr[i]前有大于arr[i]的值的化，向后移位，腾出空间，直到一个&lt;=arr[i]的值        for (j; j &gt;= 0; j--) {            if (arr[j] &gt; temp) {                arr[j + 1] = arr[j]            } else {                break            }        }        arr[j + 1] = temp    }    console.log(arr)}</code></pre><p>###选择排序</p><pre><code>const selectionSort = (arr) =&gt; {    if (arr.length &lt;= 1) return    // 需要注意这里的边界, 因为需要在内层进行 i+1后的循环，所以外层需要 数组长度-1    for (let i = 0; i &lt; arr.length - 1; i++) {        let minIndex = i        for (let j = i + 1; j &lt; arr.length; j++) {            if (arr[j] &lt; arr[minIndex]) {                minIndex = j // 找到整个数组的最小值            }        }        const temp = arr[i]        arr[i] = arr[minIndex]        arr[minIndex] = temp    }    console.log(arr)}</code></pre><p>###快速排序 </p><pre><code>const quickSort = (array,l,r) =&gt;{    if (l &gt;= r)  return;    let i =i,j = r, key = array[l];    while (i &lt; j){        while (i &lt; j &amp;&amp; array[j] &gt;= key){            j --;        }         if (i &lt; j){            array[i] = array[j];            i++;        }         while (i &lt; j &amp;&amp; array[i] &lt;= key){            i ++;        }         if (i &lt; j){            array[j] = array[i];            j --;        }         array[i] = key;        quickSort(array,l,i-1);        quickSort(array,l+1,r);    } }</code></pre><p>###归并排序  先把数组分成单个一组 然后再两两合并 </p><pre><code>const mergeArr = (left, right) =&gt; {    let temp = []    let leftIndex = 0    let rightIndex = 0    // 判断2个数组中元素大小，依次插入数组    while (left.length &gt; leftIndex &amp;&amp; right.length &gt; rightIndex) {        if (left[leftIndex] &lt;= right[rightIndex]) {            temp.push(left[leftIndex])            leftIndex++        } else {            temp.push(right[rightIndex])            rightIndex++        }    }    // 合并 多余数组    return temp.concat(left.slice(leftIndex)).concat(right.slice(rightIndex))}const mergeSort = (arr) =&gt; {    // 当任意数组分解到只有一个时返回。    if (arr.length &lt;= 1) return arr    const middle = Math.floor(arr.length / 2) // 找到中间值    const left = arr.slice(0, middle) // 分割数组    const right = arr.slice(middle)    // 递归 分解 合并    return mergeArr(mergeSort(left), mergeSort(right))}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> js javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gulp构建cocos2d-js</title>
      <link href="/2020/04/06/gulp%E6%9E%84%E5%BB%BAcocos2d-js/"/>
      <url>/2020/04/06/gulp%E6%9E%84%E5%BB%BAcocos2d-js/</url>
      
        <content type="html"><![CDATA[<p>###安装gulp<br>安装gulp命令行工具 </p><pre><code>    npm install --global gulp-cli</code></pre><p>创建目录并初始化package.json</p><pre><code>npx mkdir {my-project}cd {my-project}npm init</code></pre><p>安装 gulp，作为开发时依赖项</p><pre><code>npm install --save-dev gulpgulp --version</code></pre><p>在项目根目录下创建gulpfile.js文件  </p><p>安装插件  </p><pre><code>npm i --save-dev gulp-concat  //合并js文件 npm i --save-dev gulp-clean   // 清理某个目录 npm i --save-dev gulp-uglify   //压缩js代码 npm i --save-dev gulp-uglify-es   //压缩js代码  支持es6语法npm i --save-dev gulp-rev   //给资源文件生成映射关系 md5码 npm i --save-dev gulp-rev-collector  //根据生成的映射关系替换html中的文件名npm i --save-dev gulp-sourcemaps  //生成sourcemap插件 npm i --save-dev gulp-del  //删除文件</code></pre><p>在文件中导入插件 </p><pre><code> const {parallel,series ,src,dest } = require('gulp'); const gulp = require('gulp'); const uglify = require('gulp-uglify-es').default; //const uglify = require('gulp-uglify'); const rename = require('gulp-rename'); const concat = require('gulp-concat'); const revCollector = require('gulp-rev-collector'); const rev = require('gulp-rev');   // 生成映射 const clean = require('gulp-clean'); const sourcemap = require('gulp-sourcemaps'); const babel = require('gulp-babel'); const del = require('del')</code></pre><p>根据project.json 和moduleConfig.json文件读取引擎目录下的所有js文件</p><pre><code>let fs = require('fs');let cacheModule = {}let prex = './frameworks/cocos2d-html5/'function readJson(path){    let str = fs.readFileSync(path,'utf8');    let json = JSON.parse(str);    return json;}function readAllFiles(){    let projectCfg = readJson('./project.json');    let moduleConfig = readJson(prex + 'moduleConfig.json');    let projectModule = projectCfg['modules'];    let files = new Array();    files.push(prex + moduleConfig['bootFile']);    for(let i =0;i &lt; projectModule.length;i++){        let name = projectModule[i];        let module = moduleConfig['module'][name];        if(module){            if (cacheModule[name]) continue ;            cacheModule[name] = 1;            for(let j = 0;j &lt; module.length;j++){                let testname = module[j];                if (cacheModule[testname]) continue;                cacheModule[testname] = 1;                if(module[j].indexOf('.js') !== -1){                    files.push(prex+module[j])                }else {                    getFilesFromModule(files,moduleConfig['module'],module[j])                }            }        }    }    for (let i = 0;i &lt; projectCfg.jsList.length;i++){        files.push(projectCfg.jsList[i])    }    files.push('./game.min.js');    return files;}function getFilesFromModule(files,module,str) {    if (module[str]){        let modules = module[str];        for (let i = 0;i &lt; modules.length;i++){            let name = modules[i];            if (cacheModule[name]) continue ;            cacheModule[name] = 1;            if (name.indexOf('.js') !== -1){                files.push(prex+name)            } else {                getFilesFromModule(files,module,name)            }        }    }}</code></pre><p>打包js文件 且生成sourcemap</p><pre><code>function concatJs() {    let files = readAllFiles();    let arr = [...files];    return src(arr)        //.pipe(babel())        .pipe(sourcemap.init())        .pipe(concat('game.min.js'))        .pipe(uglify())        .pipe(sourcemap.write('./') )        .pipe(dest(`./`))}</code></pre><p>给项目目录下所有文件生成对应的映射关系，排除掉map文件不需要生成 最终映射关系在ls.json文件里面</p><pre><code>function revAllRes() {    return src([`./game.min.js`,`./res/**/*`,'!./**/*.map','!./res/data/*.json'],{base:'.'})        .pipe(rev())        .pipe(gulp.dest(`${projectPath}`))        .pipe(rev.manifest({            path: `ls.json`,            merge: true        }))        .pipe(gulp.dest(`${projectPath}/ls/`));}</code></pre><p>直接拷贝 不需要生产md5</p><pre><code>function copyOther(){    return src(['./index.html','./project.json','./res/data/*.json'],{ base:'.' })        .pipe(gulp.dest(`${projectPath}`));}</code></pre><p>修改project.json里面的参数 </p><pre><code>function changeProjectJson(cb){    let projectCfg = readJson(`${projectPath}project.json`);    delete projectCfg['modules'];    delete projectCfg['jsList'];    projectCfg['noCache'] = false;    fs.writeFileSync(`${projectPath}project.json`,JSON.stringify(projectCfg));    cb()}let child_process = require('child_process');function cleanDir(){    child_process.exec('git checkout ./')    return gulp.src(`${projectPath}`,{allowEmpty:true})        .pipe(clean({allowEmpty:true}));}</code></pre><p>根据映射关系替换html里面的文件名 这边替换需要传入映射文件以及需要替换的html文件 ，映射文件中包含的扩展名必须都列出来 否则不会生效</p><pre><code>function revHtml(){    return gulp.src([`${projectPath}ls/ls.json`,`${projectPath}*.html`])        .pipe(revCollector({            extMap:{                '.json':'.json',                '.jpg':'.jpg',                '.png':'.png',                '.plist':'.plist',                '.tmx':'.tmx',                '.ico':'.ico',            }        }))        .pipe(gulp.dest(`${projectPath}`));}exports.default = series(cleanDir,concatJs,revAllRes,copyOther,parallel(changeProjectJson,revHtml));</code></pre><p><a href="https://github.com/xiongb/gulp/blob/master/gulpfile.js" target="_blank" rel="noopener">gulpfile</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> gulp cocos2d-js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo git搭建个人博客</title>
      <link href="/2020/04/06/hexo/"/>
      <url>/2020/04/06/hexo/</url>
      
        <content type="html"><![CDATA[<h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h3><h4 id="安装完成-node-v-查看版本号"><a href="#安装完成-node-v-查看版本号" class="headerlink" title="安装完成 node -v 查看版本号"></a>安装完成 node -v 查看版本号</h4><pre class=" language-bash"><code class="language-bash"> node -v  </code></pre><p>####由于官方镜像国内访问较慢,安装成功后可设置使用淘宝镜像</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> config <span class="token keyword">set</span> registry https://registry.npm.taobao.org</code></pre><p>####可通过nrm ls查看所有镜像地址</p><pre class=" language-bash"><code class="language-bash">nrm <span class="token function">ls</span></code></pre><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><h4 id="安装成功后设置用户名邮箱"><a href="#安装成功后设置用户名邮箱" class="headerlink" title="安装成功后设置用户名邮箱"></a>安装成功后设置用户名邮箱</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> config --global user.name <span class="token string">"your name"</span><span class="token function">git</span> config --global user.email <span class="token string">"your email"</span></code></pre><p>####配置SSH key  </p><pre class=" language-bash"><code class="language-bash">ssh-keygen -t rsa -C <span class="token string">"邮件地址"</span>   // 生成key</code></pre><p>然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：</p><h4 id="验证是否成功"><a href="#验证是否成功" class="headerlink" title="验证是否成功"></a>验证是否成功</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">ssh</span> -T git@github.com <span class="token comment" spellcheck="true"># 注意邮箱地址不用改  //验证成功</span></code></pre><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><pre class=" language-bash"><code class="language-bash">    <span class="token function">npm</span> <span class="token function">install</span> -g hexo-cli</code></pre><h4 id="新建hexo工程：请执行下列命令，Hexo-将会在指定文件夹中新建所需要的文件"><a href="#新建hexo工程：请执行下列命令，Hexo-将会在指定文件夹中新建所需要的文件" class="headerlink" title="新建hexo工程：请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件"></a>新建hexo工程：请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件</h4><pre class=" language-bash"><code class="language-bash">$ hexo init <span class="token operator">&lt;</span>folder<span class="token operator">></span>$ <span class="token function">cd</span> <span class="token operator">&lt;</span>folder<span class="token operator">></span>$ <span class="token function">npm</span> <span class="token function">install</span></code></pre><p>####hexo本地部署  </p><pre class=" language-bash"><code class="language-bash">    hexo clean  清理目录    hexo g 生成静态文件     hexo s 启动本地服务器     hexo d 发布到网站 （需要特殊配置）</code></pre><p>###静态网页部署至github<br>####新建仓库<br>登陆自己的github 新建一个一个仓库 Repositories</p> <img src="/2020/04/06/hexo/1111.jpg" class=""><p>插入图片时由于官方插件有问题 这里用了别人改过的</p><pre><code>npm install https://github.com/7ym0n/hexo-asset-image --sa </code></pre><p>在Repositories name 输入 yourname.github.io,   yourname代表你自己github账号<br>待部署成功后可通过<a href="https://yourname.github.io" target="_blank" rel="noopener">https://yourname.github.io</a> 访问你部署的网站<br>####配置git<br>####安装插件 </p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save hexo-deployer-git</code></pre><p>####修改_config.yml文件<br>打开网站目录的 _config.yml<br>移动到最低端，在deploy:后面写入内容  注意空格很重要，刚开始忽略了空格出现了问题</p><pre><code>type: git    repo: github仓库地址      branch: master </code></pre><p>我的仓库地址    repo: <a href="mailto:git@github.com">git@github.com</a>:xiongb/xiongb.github.io.git</p><p>####最后通过hexo d推送到github   可通过<a href="https://yourname.github.io访问了" target="_blank" rel="noopener">https://yourname.github.io访问了</a></p><pre class=" language-bash"><code class="language-bash">hexo d</code></pre><p> <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a><br> <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a><br> <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a><br> <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">github</a>.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Hexo 相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2020/04/04/test/"/>
      <url>/2020/04/04/test/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
