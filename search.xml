<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>二叉树遍历</title>
      <link href="/2020/04/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"/>
      <url>/2020/04/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><pre><code>本身是有序树；树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2；</code></pre><h3 id="二叉树性质"><a href="#二叉树性质" class="headerlink" title="二叉树性质"></a>二叉树性质</h3><pre><code>二叉树中，第 i 层最多有 2^(i-1) 个结点。如果二叉树的深度为 K，那么此二叉树最多有 2K-1 个结点。二叉树中，终端结点数（叶子结点数）为 n0，度为 2 的结点数为 n2，则 n0=n2+1。</code></pre><p>性质 3 的计算方法为：对于一个二叉树来说，除了度为 0 的叶子结点和度为 2 的结点，剩下的就是度为 1 的结点（设为 n1），那么总结点 n=n0+n1+n2。<br>同时，对于每一个结点来说都是由其父结点分支表示的，假设树中分枝数为 B，那么总结点数 n=B+1。而分枝数是可以通过 n1 和 n2 表示的，即 B=n1+2n2。所以，n 用另外一种方式表示为 n=n1+2n2+1。<br>两种方式得到的 n 值组成一个方程组，就可以得出 n0=n2+1。</p><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><pre><code>如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为满二叉树。图1即为满二叉树。</code></pre><p>下图是本节二叉树用例图1。<br>   {% asset_img 211.jpg %}</p><p>满二叉树除了满足普通二叉树的性质，还具有以下性质：</p><pre><code>满二叉树中第 i 层的节点数为 2n-1 个。深度为 k 的满二叉树必有 2k-1 个节点 ，叶子数为 2k-1。满二叉树中不存在度为 1 的节点，每一个分支点中都两棵深度相同的子树，且叶子节点都在最底层。具有 n 个节点的满二叉树的深度为 log2(n+1)。</code></pre><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。<br>   <img src="/2020/04/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/212.jpg" class=""></p><p>如图 a) 所示是一棵完全二叉树，图 b) 由于最后一层的节点没有按照从左向右分布，因此只能算作是普通的二叉树。<br>完全二叉树除了具有普通二叉树的性质，它自身也具有一些独特的性质，比如说，n 个结点的完全二叉树的深度为 ⌊log2n⌋+1。<br>    ⌊log2​n⌋ 表示取小于 log2n的最大整数。例如，⌊log2^4 = 2，而 ⌊log2^5⌋ 结果也是 2。<br>对于任意一个完全二叉树来说，如果将含有的结点按照层次从左到右依次标号（如图 a)），对于任意一个结点 i ，完全二叉树还有以下几个结论成立：</p><pre><code>当 i&gt;1 时，父亲结点为结点 [i/2] 。（i=1 时，表示的是根结点，无父亲结点）如果 2i&gt;n（总结点的个数） ，则结点 i 肯定没有左孩子（为叶子结点）；否则其左孩子是结点 2i 。如果 2i+1&gt;n ，则结点 i 肯定没有右孩子；否则右孩子是结点 2i+1 。</code></pre><p>普通二叉树转完全二叉树的方法很简单，只需给二叉树额外添加一些节点，将其”拼凑”成完全二叉树即可。如下图所示：<br>   <img src="/2020/04/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/213.jpg" class=""></p><h3 id="二叉树的顺序存储结构"><a href="#二叉树的顺序存储结构" class="headerlink" title="二叉树的顺序存储结构"></a>二叉树的顺序存储结构</h3><pre><code>二叉树的存储结构有两种，分别为顺序存储和链式存储二叉树的顺序存储，指的是使用顺序表（数组）存储二叉树。需要注意的是，顺序存储只适用于完全二叉树。换句话说，只有完全二叉树才可以使用顺序表存储。因此，如果我们想顺序存储普通二叉树，需要提前将普通二叉树转化为完全二叉树。</code></pre><h3 id="二叉树的链式存储结构"><a href="#二叉树的链式存储结构" class="headerlink" title="二叉树的链式存储结构"></a>二叉树的链式存储结构</h3>   <img src="/2020/04/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/214.jpg" class=""><p>   如上图所示，此为一棵普通的二叉树，若将其采用链式存储，则只需从树的根节点开始，将各个节点及其左右孩子使用链表存储即可。因此，上图对应的链式存储结构如下图所示：<br>   <img src="/2020/04/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/215.jpg" class=""></p><h4 id="由图可知，采用链式存储二叉树时，其节点结构由-3-部分构成（如下图所示）："><a href="#由图可知，采用链式存储二叉树时，其节点结构由-3-部分构成（如下图所示）：" class="headerlink" title="由图可知，采用链式存储二叉树时，其节点结构由 3 部分构成（如下图所示）："></a>由图可知，采用链式存储二叉树时，其节点结构由 3 部分构成（如下图所示）：</h4><pre><code>指向左孩子节点的指针（Lchild）；节点存储的数据（data）；指向右孩子节点的指针（Rchild）；````class Node {    constructor(value) {        this.value = value;        this.left = null;        this.right = null;    }}````</code></pre><h4 id="二叉树先序遍历"><a href="#二叉树先序遍历" class="headerlink" title="二叉树先序遍历"></a>二叉树先序遍历</h4><pre><code>二叉树先序遍历的实现思想是：访问根节点；访问当前节点的左子树；若当前节点无左子树，则访问当前节点的右子树；图 1 中二叉树采用先序遍历得到的序列为：1245367function preOrderTravserse(node) {    if (node){        console.log(node.data);        preOrderTravserse(node.left);        preOrderTravserse(node.right);    }}</code></pre><h4 id="二叉树中序遍历"><a href="#二叉树中序遍历" class="headerlink" title="二叉树中序遍历"></a>二叉树中序遍历</h4><pre><code>二叉树中序遍历的实现思想是：访问当前节点的左子树；访问根节点；访问当前节点的右子树；function inOrderTravserse(node) {    if (node){        inOrderTravserse(node.left);        console.log(node.data);        inOrderTravserse(node.right);    }}</code></pre><h4 id="二叉树后序遍历"><a href="#二叉树后序遍历" class="headerlink" title="二叉树后序遍历"></a>二叉树后序遍历</h4><pre><code>二叉树后序遍历的实现思想是：从根节点出发，依次遍历各节点的左右子树，直到当前节点左右子树遍历完成后，才访问该节点元素。function postOrderTravserse(node) {    if (node){        postOrderTravserse(node.left);        postOrderTravserse(node.right);        console.log(node.data);    }}</code></pre><h4 id="二叉树层次遍历-广度优先遍历-队列：先压左节点，再压右节点"><a href="#二叉树层次遍历-广度优先遍历-队列：先压左节点，再压右节点" class="headerlink" title="二叉树层次遍历(广度优先遍历 队列：先压左节点，再压右节点)"></a>二叉树层次遍历(广度优先遍历 队列：先压左节点，再压右节点)</h4><pre><code>也就是按层次的去遍历。依次遍历根节点，然后是左孩子和右孩子。所以要遍历完当前节点的所有孩子，这样才是层次遍历嘛。此时我们就不能用栈这个数据结构了，因为栈只能在栈顶操作。在这里，我们需要根据左右孩子的顺序来输出，所以就是先进先出的原则，那么我们当然就想到了队列这个数据结构。可以在rear依次插入左右孩子，在front依次读取并删除左右孩子，这样就保证了层次的输出。function BFS(root) {    let queue = [];    if (root === null) return;    queue.push(root);    while (queue.length){        let node = queue.shift();        console.log(node.data)        if (node.left){            queue.push(node.left)        }        if (node.right){            queue.push(node.right)        }    }}</code></pre><h4 id="深度优先遍历（栈，先压右节点，再压左节点）"><a href="#深度优先遍历（栈，先压右节点，再压左节点）" class="headerlink" title="深度优先遍历（栈，先压右节点，再压左节点）"></a>深度优先遍历（栈，先压右节点，再压左节点）</h4><pre><code>也就深入的遍历，沿着每一个分支直到走到最后，然后才返回来遍历剩余的节点。二叉树不同于图，图需要标记节点是否已经访问过，因为可能会存在环，而二叉树不会出现环，所以不需要标记。那么，我们只需要一个栈空间，来压栈就好了。因为深度优先遍历，遍历了根节点后，就开始遍历左子树，所以右子树肯定最后遍历。我们利用栈的性质，先将右子树压栈，然后在对左子树压栈。此时，左子树节点是在top上的，所以可以先去遍历左子树。function DFS(root) {    let stack = []    if (root === null) return;    stack.push(root);    while (stack.length){        let node = stack.pop();        if (node.right){            stack.push(node.right)        }        if (node.left){            stack.push(node.left)        }        console.log(node.data)    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈js</title>
      <link href="/2020/04/08/%E6%A0%88js/"/>
      <url>/2020/04/08/%E6%A0%88js/</url>
      
        <content type="html"><![CDATA[<pre><code>/** * 基于链表实现的栈。 * * Author: nameczz */class Node {    constructor(element) {        this.element = element        this.next = null    }}class StackBasedLinkedList {    constructor() {        this.top = null    }    push(value) {        const node = new Node(value)        if (this.top === null) {            this.top = node        } else {            node.next = this.top            this.top = node        }    }    pop() {        if (this.top === null) {            return -1        }        const value = this.top.element        this.top = this.top.next        return value    }    // 为了实现浏览器前进后退    clear() {        this.top = null    }    display() {        if (this.top !== null) {            let temp = this.top            while (temp !== null) {                console.log(temp.element)                temp = temp.next            }        }    }}// Testconst newStack = new StackBasedLinkedList()newStack.push(1)newStack.push(2)newStack.push(3)// 获取元素let res = 0console.log('-------获取pop元素------')while (res !== -1) {    res = newStack.pop()    console.log(res)}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> js 栈 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列</title>
      <link href="/2020/04/08/%E9%98%9F%E5%88%97js/"/>
      <url>/2020/04/08/%E9%98%9F%E5%88%97js/</url>
      
        <content type="html"><![CDATA[<pre><code>/** * 基于链表实现的队列。 * * Author: nameczz */class Node {    constructor(element) {        this.element = element        this.next = null    }}class QueueBasedOnLinkedList {    constructor() {        this.head = null        this.tail = null    }    enqueue(value) {        if (this.head === null) {            this.head = new Node(value)            this.tail = this.head        } else {            this.tail.next = new Node(value)            this.tail = this.tail.next        }    }    dequeue() {        if (this.head !== null) {            const value = this.head.element            this.head = this.head.next            return value        } else {            return -1        }    }}// Testconst newQueue = new QueueBasedOnLinkedList()// 插入元素newQueue.enqueue(1)newQueue.enqueue(2)newQueue.enqueue(3)// 获取元素let res = 0console.log('-------获取dequeue元素------')while (res !== -1) {    res = newQueue.dequeue()    console.log(res)}</code></pre><pre><code>/** * 基于链表实现的循环队列。 * * Author: nameczz */class Node {    constructor(element) {        this.element = element        this.next = null    }}class CircularQueue {    constructor() {        this.head = null        this.tail = null    }    enqueue(value) {        if (this.head === null) {            this.head = new Node(value)            this.head.next = this.head            this.tail = this.head        } else {            const flag = this.head === this.tail            this.tail.next = new Node(value)            this.tail.next.next = this.head            this.tail = this.tail.next            if (flag) {                this.head.next = this.tail            }        }    }    dequeue() {        if(this.head == null) return -1        if (this.head === this.tail) {            const value = this.head.element            this.head = null            return value        } else {            const value = this.head.element            this.head = this.head.next            this.tail.next = this.head            return value        }     }    display() {        let res = 0        console.log('-------获取dequeue元素------')        while (res !== -1) {            res = this.dequeue()            console.log(res)        }    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> js 队列 循环队列 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2020/04/08/%E9%93%BE%E8%A1%A8js/"/>
      <url>/2020/04/08/%E9%93%BE%E8%A1%A8js/</url>
      
        <content type="html"><![CDATA[<ul><li>1) 单链表反转</li><li>2) 链表中环的检测</li><li>3) 两个有序的链表合并</li><li>4) 删除链表倒数第n个结点</li><li>5) 求链表的中间结点</li></ul><pre><code>class Node {    constructor(element) {        this.element = element        this.next = null    }}class LinkedList {    constructor() {        this.head = new Node('head')    }    // 根据value查找节点     findByValue(item) {        let currentNode = this.head        while (currentNode !== null &amp;&amp; currentNode.element !== item) {            currentNode = currentNode.next        }        return currentNode === null ? -1 : currentNode    }    // 根据index查找节点     findByIndex(index) {        let currentNode = this.head        let pos = 0        while (currentNode !== null &amp;&amp; pos !== index) {            currentNode = currentNode.next            pos++        }        return currentNode === null ? -1 : currentNode    }    // 指定元素向后插入    insert(newElement, element) {        const currentNode = this.findByValue(element)        if (currentNode === -1) {            console.log('未找到插入位置')            return        }        const newNode = new Node(newElement)        newNode.next = currentNode.next        currentNode.next = newNode    }    // 查找前一个    findPrev(item) {        let currentNode = this.head        while (currentNode.next !== null &amp;&amp; currentNode.next.element !== item) {            currentNode = currentNode.next        }        if (currentNode.next === null) {            return -1        }        return currentNode    }    // 根据值删除    remove(item) {        const desNode = this.findByValue(item)        if (desNode === -1) {            console.log('未找到元素')            return        }        const prevNode = this.findPrev(item)        prevNode.next = desNode.next    }    // 遍历显示所有节点    display() {        //先检查是否为环        if(this.checkCircle()) return false        let currentNode = this.head        while (currentNode !== null) {            console.log(currentNode.element)            currentNode = currentNode.next        }    }    // 尾插法 反转单链表    reverseList() {        const root = new Node('head')        let currentNode = this.head.next        while (currentNode !== null) {            const next = currentNode.next            currentNode.next = root.next            root.next = currentNode            currentNode = next        }        this.head = root    }    //增强尾插法可读性，便于初学者理解    reverseList1(){      //head节点即哨兵，作用就是使所有链表，      // 包括空链表的头节点不为null,并使对单链表的插入、删除操作不需要区分是否为空表或是否在第一个位置进行，      // 从而与其他位置的插入、删除操作一致      //所以反转链表的时候不需要带上head节点      let currentNode=this.head.next      //第一个节点头结点让其指向null      let previousNode=null      while(currentNode!==null){        //务必先保留下一节点的指针地址        let nextNode=currentNode.next        //第一次是null        currentNode.next=previousNode        //此时将previousNode赋值为当前节点，        // 那么下次循环的时候，方便下次的currentNode指向previousNode        previousNode=currentNode        //抬走，下一个！        currentNode=nextNode      }    //最后将反转好的链表加上头节点    this.head.next=previousNode    }    // 自己一开始瞎想的。差距啊    reverseList2() {        let currentNode = this.head.next        let reverseList = new LinkedList()        const tempArr = []        if (currentNode === null || currentNode.next === null) {            console.log('节点数小于3，不反转')            return        }        while (currentNode !== null) {            tempArr.push(currentNode)            currentNode = currentNode.next        }        for (let i = tempArr.length - 1; i &gt;= 0; i--) {            const key = i === tempArr.length - 1 ? 'head' : tempArr[i + 1].element            reverseList.insert(tempArr[i].element, key)        }        reverseList.display()        return reverseList    }    // 环验证    checkCircle() {        let fast = this.head.next        let slow = this.head        while (fast !== null &amp;&amp; fast.next !== null) {            fast = fast.next.next            slow = slow.next            if (slow === fast) return true        }        return false    }    // 删除倒数第k个节点    removeByIndexFromEnd(index) {        //务必先判断是否是 环链表        if(this.checkCircle()) return false        let pos = 1        this.reverseList()        let currentNode = this.head.next        while (currentNode !== null &amp;&amp; pos &lt; index) {            currentNode = currentNode.next            pos++        }        if (currentNode === null) {            console.log('无法删除最后一个节点或者该节点不存在')            return false        }        this.remove(currentNode.element)        this.reverseList()    }    // 求中间节点    findMiddleNode() {        let fast = this.head        let slow = this.head        while (fast.next !== null &amp;&amp; fast.next.next !== null) {            fast = fast.next.next            slow = slow.next        }        console.log(slow)        return slow    }}const mergeSortedLists = (listA, listB) =&gt; {    if (!listA) {        return listB    }    if (!listB) {        return listA    }    let a = listA    let b = listB    let resultList = undefined    if (a.element &lt; b.element) {        resultList = a        a = a.next    } else {        resultList = b        b = b.next    }    let currentNode = resultList    while (a !== null &amp;&amp; b !== null) {        if (a.element &lt; b.element) {            currentNode.next = a            a = a.next        } else {            currentNode.next = b            b = b.next        }        currentNode = currentNode.next    }    if (a != null) {        currentNode.next = a    } else {        currentNode.next = b    }    return resultList}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> js 算法 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2020/04/08/%E6%95%B0%E7%BB%84/"/>
      <url>/2020/04/08/%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>与 Java 、PHP 等语言不同，在 JavaScript 中，数组其实是一种特殊的对象。</p><h4 id="数组的创建与读写"><a href="#数组的创建与读写" class="headerlink" title="数组的创建与读写"></a>数组的创建与读写</h4><p>以下两种方式都可创建数组：</p><pre><code>// 字面量方式,常用var num = [1,5,6,10];print(num.length);   // 4// 构造函数方式var num = new Array(1,5,6,10);print(num.length);    // 4</code></pre><p>值得注意的是，JavaScript 中的数组数据可以是不同类型，它的语法相对宽松，例如可以指定不同类型数据<code>var example = [1,"Mike",true,null];</code>另外，可以通过<code>Array.isArray()</code>来判断一个对象是否是数组，例如：</p><pre><code>var num = [1,5,6,10];print(Array.isArray(num));        // true</code></pre><p>如何读写数组呢？可以使用循环。</p><pre><code>var num = [1,5,6,10];for (var i = 0; i &lt; num.length; i++) {  console.log(num[i]+" ");}</code></pre><h4 id="数组的深复制与浅复制"><a href="#数组的深复制与浅复制" class="headerlink" title="数组的深复制与浅复制"></a>数组的深复制与浅复制</h4><p>当我们把数组赋给另外一个数组，然后改变其中一个数组的值，另一数组也会随之改变，这就是数组的浅复制。而深复制指的就是不改变原来的数组而去创建一个新的数组，这种情况是经常使用的，为了不破坏原数组。下面的代码展示了这两种复制</p><pre><code>// 浅复制var num = [1,2,3,4,5];var newNum = num;num[0] = 10;console.log(newNum[0]);  // 10// 深复制function copy (arr1,arr2) {  for(var i=0;i&lt;arr1.length;i++){    arr2[i] = arr1[i];  }}var num = [1,5,6,7,9];var newNum = [];copy(num,newNum);num[0] = 10;console.log(newNum[0]);    // 仍然为 1</code></pre><h4 id="存取函数"><a href="#存取函数" class="headerlink" title="存取函数"></a>存取函数</h4><p>JavaScript 提供了一组用来访问数组元素的函数，叫存取函数。最常用的存取函数就是 indexOf() 函数，该函数返回指定查找的值在目标值中是否存在，如果存在，返回该值在数组中的索引，不存在则返回 -1。</p><pre><code>var word = ["A","B","C","D"];var result = word.indexOf("A");console.log(result);    // 0var test = word.indexOf("F");console.log(test);   // -1</code></pre><p>除此之外，还有 join 和 toString 函数，concat 和 splice 函数。前两个函数可以将数组转化为字符串，后面两个函数可以通过已有的数组创建新数组，其中 concat 方法通过合并多个数组来形成新数组，而 splice 方法是截取一个数组的子集作为一个新数组。它们的使用示例如下</p><pre><code>var arr = ["Mike","John","Hexo"];console.log(arr.join());   // Mike,John,Hexoconsole.log(arr.toString());   // Mike,John,Hexovar arr1 = [1,10,"Mike"];var arr2 = [8,7,6];var cat = arr1.concat(arr2);console.log(cat);    // [1, 10, "Mike", 8, 7, 6]var num = [1,2,3,4,5,6,7];var a = num.splice(3,2);     // 3 表示索引，2 表示删除 2 个console.log(num);      // [1, 2, 3, 6, 7]    </code></pre><h4 id="可变函数"><a href="#可变函数" class="headerlink" title="可变函数"></a>可变函数</h4><p>不去引用数组中的某个元素，就能改变数组内容，这种函数称它为可变函数。</p><h6 id="push-和-unshift-、pop-和-shift"><a href="#push-和-unshift-、pop-和-shift" class="headerlink" title="push() 和 unshift()、pop() 和 shift()"></a>push() 和 unshift()、pop() 和 shift()</h6><p>push() 方法可以在数组末尾添加元素，而 unshift() 方法可以在数组开头添加元素；相对应的，pop 可以删除数组末尾的元素，而 shift 删除数组的第一个元素。</p><pre><code>var nums = [9,58,15,16,23];nums.push(111);console.log(nums);   // 9, 58, 15, 16, 23, 111nums.unshift(1);console.log(nums);   // 1, 9, 58, 15, 16, 23, 111nums.pop();console.log(nums);   // 1, 9, 58, 15, 16, 23nums.shift();console.log(nums);   // 9, 58, 15, 16, 23</code></pre><h6 id="splice-、sort-、reverse"><a href="#splice-、sort-、reverse" class="headerlink" title="splice()、sort()、reverse()"></a>splice()、sort()、reverse()</h6><p>前面提到的 splice 不仅可以用来删除元素，还可以添加元素进数组。用 sort 可以为数组排序，reverse 将数组内的元素翻转。</p><pre><code>var num = [98,99,100,101];num.splice(1,0,89);     // 1 表示索引，0 表示不删除元素，89 表示将 89 这个元素添加进数组console.log(num);    // 98, 89, 99, 100, 101num.reverse();console.log(num);    //  101, 100, 99, 89, 98</code></pre><p>关于 sort 方法非常有意思，它只能对那些字符串类型的元素排列得比较准确，但如果是数字，结果就不那么令人满意了。看看例子.</p><pre><code>var str = ["hello","client","zero"];str.sort();console.log(str);     // ["client", "hello", "zero"]  按照字母 a-z 排列准确var nums = [1,200,51,66,88];nums.sort();console.log(nums);   // [1, 200, 51, 66, 88]  有趣的事情来了，因为 200 的 2 比 51 的 5 先，所以 200 排在 51 前头</code></pre><p>那如何解决这种排序的错误呢？方法就是在调用 sort() 的时候传入一个函数，该函数可以比较出大小。</p><pre><code>function compare(num1,num2){  return num1 - num2;}var nums = [3,1,2,100,4,200];nums.sort(compare);console.log(nums);    // 1, 2, 3, 4, 100, 200</code></pre><p>可以看到，已经排序正确了，compare 函数就是利用了两数相减，如果结果为正，那么被减数大于减数，如果结果为 0，则两数相等，而如果结果为负，说明被减数小于减数。</p><h4 id="迭代器方法"><a href="#迭代器方法" class="headerlink" title="迭代器方法"></a>迭代器方法</h4><p>迭代函数通过对数组中的元素逐个应用，来操作返回相应的值。</p><h6 id="不返回新数组的-forEach-、every-、some-、reduce"><a href="#不返回新数组的-forEach-、every-、some-、reduce" class="headerlink" title="不返回新数组的 forEach() 、every()、some()、reduce()"></a>不返回新数组的 forEach() 、every()、some()、reduce()</h6><pre><code>// 用 forEach 开方function square(num) {    console.log(num,num*num);}var num = [1,2,3,4,5];num.forEach(square);console.log(num);/*  1 1    2 4    3 9    4 16    5 25*/</code></pre><pre><code>/*every() 返回值为布尔类型，对于应用的所有元素，该函数返回 true，则该方法返回 true*/function isEven(num){  return num % 2 == 0;}var num = [2,4,6,8,10];var even = num.every(isEven);if(even){  console.log("所有的数字都是偶数");}else{  console.log("不是所有的数字都是偶数");}</code></pre><pre><code>/*some() 与 every() 的不同就是只要有一个元素使改函数返回 true ，那么该方法就返回 true*/function isEven(num){  return num % 2 == 0;}var num = [1,2,3,4,5,6,7,8];var someEven = num.some(isEven);if(someEven){  console.log("有些数字是偶数");}else{  console.log("没有数字是偶数");}</code></pre><pre><code>/*reduce() 有两个功能，一是可以对数组元素进行求和，二是将数组元素连接成字符串。*/fucntion add(num1,num2){  return num1 + num2;}var num = [1,2,3,4];var sum = num.reduce(add);console.log(sum);    // 10function concat(str,i) {  return str + i;}var words = ["I am ","a ","coder "];var re = words.reduce(concat);console.log(re);     // I am a coder</code></pre><h6 id="返回新数组的-map-和-filter"><a href="#返回新数组的-map-和-filter" class="headerlink" title="返回新数组的 map() 和 filter()"></a>返回新数组的 map() 和 filter()</h6><p>map 的作用与 forEach 是一样的，区别就是 map 函数返回的是一个新数组。</p><pre><code>function addFive(grade){  return grade += 5;}var grade = [77,82,88,95,90];var result = grade.map(addFive);console.log(result);     // 82, 87, 93, 100, 95</code></pre><p>而 filter 和 every 相似，区别在于当所有的元素使改函数为 true 时，它并不返回布尔类型，而是返回一个新数组。下面这个例子十分有趣，它随机产生10个 0 到 100 的数字作为分数，然后把大于 60 的及格分数筛选出来。</p><pre><code>function passing(num){  return num &gt;= 60;}var grades = [];for(var i = 0;i &lt; 11;i++){  grade[i] = Math.floor(Math.random() * 101);}var pass = grades.filter(passing);console.log("随机产生的 10 个同学的分数为：");console.log(grades)；console.log("及格的分数有：");console.log(pass)；</code></pre><p>上述代码的输出结果为</p><blockquote><p>随机产生的 10 个同学的分数为：<br>21, 4, 89, 45, 5, 51, 71, 7, 46, 53, 47<br>及格的分数有：<br>89, 71</p></blockquote><h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><p>JavaScript 可以通过在数组里在嵌套一个数组来形成二维数组。</p><pre><code>var grades = [  [88,86,82],  [91,82,83],  [77,72,79],  [86,80,82]];console.log(grades[1][2]);    // 83</code></pre><h4 id="处理二维数组"><a href="#处理二维数组" class="headerlink" title="处理二维数组"></a>处理二维数组</h4><p>对于二维数组的处理可以分为两种，一种按列访问，一种是按行访问。<br>按列访问，外层循环对应行，内层循环对应列。例如，上述的数组，每一行对应一个学生三门科目的成绩记录，可以通过相加所有成绩，然后除以科目数来得到该生的平均成绩。</p><pre><code>var grades = [  [88,86,82],  [91,82,83],  [77,72,79],  [86,80,82]];var total = 0;var average = 0.0;for(var row = 0;row&lt;grades.length;++row){  for(var col = 0;col&lt;grades[row].length;++col){    total += grades[row][col];  }  average = total/grades[row].length;  console.log("student "+parseInt(row+1)+" average: "+average.toFixed(2));   // toFixed 表示按照 2 位来保留小数  total = 0;  average = 0.0;}</code></pre><p>上述代码的输出结果为</p><blockquote><p>student 1 average: 85.33<br>student 2 average: 85.33<br>student 3 average: 76.00<br>student 4 average: 82.67</p></blockquote><p>对于按行访问，则外层循环对应列，内层循环对应行，例如还是上述数组，现在的数组表示一个学生三场考试四门科目的各科分数，我们来求每场考试的平均成绩</p><pre><code>var grades = [  [88,86,82],  [91,82,83],  [77,72,79],  [86,80,82]];var total = 0;var average = 0.0;//这里假设每场考试的科目都一样，所以可以通过grades[0].length来获取考试数量for(var col = 0;col &lt;grades[0].length;++col ){  for(var row= 0;row&lt;grades.length;++row){    total += grades[row][col];  }  average = total/grades.length;  console.log("exam "+parseInt(col +1)+" average: "+average.toFixed(2));  total = 0;  average = 0.0;}</code></pre><p>输出结果为：</p><blockquote><p>exam 1 average: 85.50<br>exam 2 average: 80.00<br>exam 3 average: 81.50</p></blockquote><p>其实只要调整 for 循环的顺序就可以控制是按行还是按列来输出，此外，JavaScript 还可以处理一些参差不齐的数组，比如一个二维数组中的数组，有的是两个元素，有的是四个元素，并不是都相同，在这种情况下，JavaScript 依然可以处理运行而不报错，这是因为不管多或少，都可以通过 length 属性来计算。</p><h4 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h4><p>如果你有阅读到这里，你应该可以发现上面的所有例子里数据类型都是基本数据类型，不是数字就是字符串。对象数组，顾名思义，就是数组里面的元素可以是对象，这个与 java 的语法很相似，基本上所有的编程语言都是相通的。看看下面这个例子：</p><pre><code>function point(x,y){  this.x = x;  this.y = y;}function show(arr){  for(var i=0;i&lt;arr.length;i++){    console.log(arr[i].x + ", "+arr[i].y);  }}var p1 = new Point(1,2);var p2 = new Point(2,4);var p3 = new Point(8,1);var p4 = new Point(2,9);var point = [p1,p2,p3,p4];for(var i=0;i&lt;point.lengh;i++){  console.log("Point "+parseInt(i+1)+": "+point[i].x+", "+point[i].y);}</code></pre><p>上述程序的输出结果为：</p><blockquote><p>Point 1: 1, 2<br>Point 2: 2, 4<br>Point 3: 8, 1<br>Point 4: 2, 9</p></blockquote><p>也可以用之前的 push() 等操作方法来操作对象数组</p><pre><code>var p5 = new Point(11,13);point.push(p5);console.log("添加了 p5 后：");show(point);     point.shift();console.log("删除第一个元素后：")show(point);</code></pre><p>输出结果为：</p><blockquote><p>添加了 p5 后：<br>1,2<br>2,4<br>8,1<br>2,9<br>11,13<br>删除第一个元素后：<br>2,4<br>8,1<br>2,9<br>11,13</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> js 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找js版</title>
      <link href="/2020/04/08/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BEjs%E7%89%88/"/>
      <url>/2020/04/08/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BEjs%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h3 id="数组必须有序不存在重复-查找target的位置"><a href="#数组必须有序不存在重复-查找target的位置" class="headerlink" title="数组必须有序不存在重复,查找target的位置"></a>数组必须有序不存在重复,查找target的位置</h3><pre><code>const biaryFind = (sortedArr, target) =&gt; {    if (sortedArr.length === 0) return -1    let low = 0    let high = sortedArr.length - 1    while (low &lt;= high) {        const mid = Math.floor((low + high) / 2)        if (target === sortedArr[mid]) {            return mid        } else if (target &lt; sortedArr[mid]) {            high = mid - 1        } else {            low = mid + 1        }    }    return -1}</code></pre><h3 id="查找第一个等于给定值"><a href="#查找第一个等于给定值" class="headerlink" title="查找第一个等于给定值"></a>查找第一个等于给定值</h3><pre><code>const biaryFindFirst = (sortedArr, target) =&gt; {    if (sortedArr.length === 0) return -1    let low = 0    let high = sortedArr.length - 1    while (low &lt;= high) {        const mid = Math.floor((low + high) / 2)        if (target &lt; sortedArr[mid]) {            high = mid - 1        } else if (target &gt; sortedArr[mid]) {            low = mid + 1        } else {            if (mid === 0 || sortedArr[mid - 1] &lt; target) return mid            high = mid - 1        }    }    return -1}</code></pre><h3 id="查找最后一个相等的数"><a href="#查找最后一个相等的数" class="headerlink" title="查找最后一个相等的数"></a>查找最后一个相等的数</h3><pre><code>const biaryFindLast = (sortedArr, target) =&gt; {    if (sortedArr.length === 0) return -1    let low = 0    let high = sortedArr.length - 1    while (low &lt;= high) {        const mid = Math.floor((low + high) / 2)        if (target &lt; sortedArr[mid]) {            high = mid - 1        } else if (target &gt; sortedArr[mid]) {            low = mid + 1        } else {            if (mid === sortedArr.length - 1 || sortedArr[mid + 1] &gt; target) return mid            low = mid + 1        }    }    return -1}</code></pre><h3 id="查找第一个大于等于给定值的元素"><a href="#查找第一个大于等于给定值的元素" class="headerlink" title="查找第一个大于等于给定值的元素"></a>查找第一个大于等于给定值的元素</h3><pre><code>const biaryFindFistBig = (sortedArr, target) =&gt; {    if (sortedArr.length === 0) return -1    let low = 0    let high = sortedArr.length - 1    while (low &lt;= high) {        const mid = Math.floor((low + high) / 2)        if (target &lt;= sortedArr[mid]) {            if (mid === 0 || sortedArr[mid - 1] &lt; target) return mid            high = mid - 1        } else {            low = mid + 1        }    }    return -1}</code></pre><h3 id="查找最后一个小于等于给定值的元素"><a href="#查找最后一个小于等于给定值的元素" class="headerlink" title="查找最后一个小于等于给定值的元素"></a>查找最后一个小于等于给定值的元素</h3><pre><code>const biaryFindLastSmall = (sortedArr, target) =&gt; {    if (sortedArr.length === 0) return -1    let low = 0    let high = sortedArr.length - 1    while (low &lt;= high) {        const mid = Math.floor((low + high) / 2)        if (target &lt; sortedArr[mid]) {            high = mid - 1        } else {            if (mid === sortedArr.length - 1 || sortedArr[mid + 1] &gt;= target) return mid            low = mid + 1        }    }    return -1}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 二分查找 算法 js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法js版</title>
      <link href="/2020/04/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95js/"/>
      <url>/2020/04/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95js/</url>
      
        <content type="html"><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><pre><code>const bubbleSort = (arr) =&gt; {    if (arr.length &lt;= 1) return    for (let i = 0; i &lt; arr.length; i++) {        let hasChange = false        for (let j = 0; j &lt; arr.length - i - 1; j++) {            if (arr[j] &gt; arr[j + 1]) {                const temp = arr[j]                arr[j] = arr[j + 1]                arr[j + 1] = temp                hasChange = true            }        }        // 如果false 说明所有元素已经到位        if (!hasChange) break    }    console.log(arr)}</code></pre><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><pre><code>const insertionSort = (arr) =&gt; {    if (arr.length &lt;= 1) return    for (let i = 1; i &lt; arr.length; i++) {        const temp = arr[i]        let j = i - 1        // 若arr[i]前有大于arr[i]的值的化，向后移位，腾出空间，直到一个&lt;=arr[i]的值        for (j; j &gt;= 0; j--) {            if (arr[j] &gt; temp) {                arr[j + 1] = arr[j]            } else {                break            }        }        arr[j + 1] = temp    }    console.log(arr)}</code></pre><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><pre><code>const selectionSort = (arr) =&gt; {    if (arr.length &lt;= 1) return    // 需要注意这里的边界, 因为需要在内层进行 i+1后的循环，所以外层需要 数组长度-1    for (let i = 0; i &lt; arr.length - 1; i++) {        let minIndex = i        for (let j = i + 1; j &lt; arr.length; j++) {            if (arr[j] &lt; arr[minIndex]) {                minIndex = j // 找到整个数组的最小值            }        }        const temp = arr[i]        arr[i] = arr[minIndex]        arr[minIndex] = temp    }    console.log(arr)}</code></pre><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><pre><code>const quickSort = (array,l,r) =&gt;{    if (l &gt;= r)  return;    let i =i,j = r, key = array[l];    while (i &lt; j){        while (i &lt; j &amp;&amp; array[j] &gt;= key){            j --;        }         if (i &lt; j){            array[i] = array[j];            i++;        }         while (i &lt; j &amp;&amp; array[i] &lt;= key){            i ++;        }         if (i &lt; j){            array[j] = array[i];            j --;        }         array[i] = key;        quickSort(array,l,i-1);        quickSort(array,l+1,r);    } }</code></pre><h3 id="归并排序-先把数组分成单个一组-然后再两两合并"><a href="#归并排序-先把数组分成单个一组-然后再两两合并" class="headerlink" title="归并排序  先把数组分成单个一组 然后再两两合并"></a>归并排序  先把数组分成单个一组 然后再两两合并</h3><pre><code>const mergeArr = (left, right) =&gt; {    let temp = []    let leftIndex = 0    let rightIndex = 0    // 判断2个数组中元素大小，依次插入数组    while (left.length &gt; leftIndex &amp;&amp; right.length &gt; rightIndex) {        if (left[leftIndex] &lt;= right[rightIndex]) {            temp.push(left[leftIndex])            leftIndex++        } else {            temp.push(right[rightIndex])            rightIndex++        }    }    // 合并 多余数组    return temp.concat(left.slice(leftIndex)).concat(right.slice(rightIndex))}const mergeSort = (arr) =&gt; {    // 当任意数组分解到只有一个时返回。    if (arr.length &lt;= 1) return arr    const middle = Math.floor(arr.length / 2) // 找到中间值    const left = arr.slice(0, middle) // 分割数组    const right = arr.slice(middle)    // 递归 分解 合并    return mergeArr(mergeSort(left), mergeSort(right))}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> js javascript 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gulp构建cocos2d-js</title>
      <link href="/2020/04/06/gulp%E6%9E%84%E5%BB%BAcocos2d-js/"/>
      <url>/2020/04/06/gulp%E6%9E%84%E5%BB%BAcocos2d-js/</url>
      
        <content type="html"><![CDATA[<h3 id="安装gulp"><a href="#安装gulp" class="headerlink" title="安装gulp"></a>安装gulp</h3><p>安装gulp命令行工具 </p><pre><code>    npm install --global gulp-cli</code></pre><p>创建目录并初始化package.json</p><pre><code>npx mkdir {my-project}cd {my-project}npm init</code></pre><p>安装 gulp，作为开发时依赖项</p><pre><code>npm install --save-dev gulpgulp --version</code></pre><p>在项目根目录下创建gulpfile.js文件  </p><p>安装插件  </p><pre><code>npm i --save-dev gulp-concat  //合并js文件 npm i --save-dev gulp-clean   // 清理某个目录 npm i --save-dev gulp-uglify   //压缩js代码 npm i --save-dev gulp-uglify-es   //压缩js代码  支持es6语法npm i --save-dev gulp-rev   //给资源文件生成映射关系 md5码 npm i --save-dev gulp-rev-collector  //根据生成的映射关系替换html中的文件名npm i --save-dev gulp-sourcemaps  //生成sourcemap插件 npm i --save-dev gulp-del  //删除文件</code></pre><p>在文件中导入插件 </p><pre><code> const {parallel,series ,src,dest } = require('gulp'); const gulp = require('gulp'); const uglify = require('gulp-uglify-es').default; //const uglify = require('gulp-uglify'); const rename = require('gulp-rename'); const concat = require('gulp-concat'); const revCollector = require('gulp-rev-collector'); const rev = require('gulp-rev');   // 生成映射 const clean = require('gulp-clean'); const sourcemap = require('gulp-sourcemaps'); const babel = require('gulp-babel'); const del = require('del')</code></pre><p>根据project.json 和moduleConfig.json文件读取引擎目录下的所有js文件</p><pre><code>let fs = require('fs');let cacheModule = {}let prex = './frameworks/cocos2d-html5/'function readJson(path){    let str = fs.readFileSync(path,'utf8');    let json = JSON.parse(str);    return json;}function readAllFiles(){    let projectCfg = readJson('./project.json');    let moduleConfig = readJson(prex + 'moduleConfig.json');    let projectModule = projectCfg['modules'];    let files = new Array();    files.push(prex + moduleConfig['bootFile']);    for(let i =0;i &lt; projectModule.length;i++){        let name = projectModule[i];        let module = moduleConfig['module'][name];        if(module){            if (cacheModule[name]) continue ;            cacheModule[name] = 1;            for(let j = 0;j &lt; module.length;j++){                let testname = module[j];                if (cacheModule[testname]) continue;                cacheModule[testname] = 1;                if(module[j].indexOf('.js') !== -1){                    files.push(prex+module[j])                }else {                    getFilesFromModule(files,moduleConfig['module'],module[j])                }            }        }    }    for (let i = 0;i &lt; projectCfg.jsList.length;i++){        files.push(projectCfg.jsList[i])    }    files.push('./game.min.js');    return files;}function getFilesFromModule(files,module,str) {    if (module[str]){        let modules = module[str];        for (let i = 0;i &lt; modules.length;i++){            let name = modules[i];            if (cacheModule[name]) continue ;            cacheModule[name] = 1;            if (name.indexOf('.js') !== -1){                files.push(prex+name)            } else {                getFilesFromModule(files,module,name)            }        }    }}</code></pre><p>打包js文件 且生成sourcemap</p><pre><code>function concatJs() {    let files = readAllFiles();    let arr = [...files];    return src(arr)        //.pipe(babel())        .pipe(sourcemap.init())        .pipe(concat('game.min.js'))        .pipe(uglify())        .pipe(sourcemap.write('./') )        .pipe(dest(`./`))}</code></pre><p>给项目目录下所有文件生成对应的映射关系，排除掉map文件不需要生成 最终映射关系在ls.json文件里面</p><pre><code>function revAllRes() {    return src([`./game.min.js`,`./res/**/*`,'!./**/*.map','!./res/data/*.json'],{base:'.'})        .pipe(rev())        .pipe(gulp.dest(`${projectPath}`))        .pipe(rev.manifest({            path: `ls.json`,            merge: true        }))        .pipe(gulp.dest(`${projectPath}/ls/`));}</code></pre><p>直接拷贝 不需要生产md5</p><pre><code>function copyOther(){    return src(['./index.html','./project.json','./res/data/*.json'],{ base:'.' })        .pipe(gulp.dest(`${projectPath}`));}</code></pre><p>修改project.json里面的参数 </p><pre><code>function changeProjectJson(cb){    let projectCfg = readJson(`${projectPath}project.json`);    delete projectCfg['modules'];    delete projectCfg['jsList'];    projectCfg['noCache'] = false;    fs.writeFileSync(`${projectPath}project.json`,JSON.stringify(projectCfg));    cb()}let child_process = require('child_process');function cleanDir(){    child_process.exec('git checkout ./')    return gulp.src(`${projectPath}`,{allowEmpty:true})        .pipe(clean({allowEmpty:true}));}</code></pre><p>根据映射关系替换html里面的文件名 这边替换需要传入映射文件以及需要替换的html文件 ，映射文件中包含的扩展名必须都列出来 否则不会生效</p><pre><code>function revHtml(){    return gulp.src([`${projectPath}ls/ls.json`,`${projectPath}*.html`])        .pipe(revCollector({            extMap:{                '.json':'.json',                '.jpg':'.jpg',                '.png':'.png',                '.plist':'.plist',                '.tmx':'.tmx',                '.ico':'.ico',            }        }))        .pipe(gulp.dest(`${projectPath}`));}exports.default = series(cleanDir,concatJs,revAllRes,copyOther,parallel(changeProjectJson,revHtml));</code></pre><p><a href="https://github.com/xiongb/gulp/blob/master/gulpfile.js" target="_blank" rel="noopener">gulpfile</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> gulp cocos2d-js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo git搭建个人博客</title>
      <link href="/2020/04/06/hexo/"/>
      <url>/2020/04/06/hexo/</url>
      
        <content type="html"><![CDATA[<h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h3><h4 id="安装完成-node-v-查看版本号"><a href="#安装完成-node-v-查看版本号" class="headerlink" title="安装完成 node -v 查看版本号"></a>安装完成 node -v 查看版本号</h4><pre class=" language-bash"><code class="language-bash"> node -v  </code></pre><h4 id="由于官方镜像国内访问较慢-安装成功后可设置使用淘宝镜像"><a href="#由于官方镜像国内访问较慢-安装成功后可设置使用淘宝镜像" class="headerlink" title="由于官方镜像国内访问较慢,安装成功后可设置使用淘宝镜像"></a>由于官方镜像国内访问较慢,安装成功后可设置使用淘宝镜像</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> config <span class="token keyword">set</span> registry https://registry.npm.taobao.org</code></pre><h4 id="可通过nrm-ls查看所有镜像地址"><a href="#可通过nrm-ls查看所有镜像地址" class="headerlink" title="可通过nrm ls查看所有镜像地址"></a>可通过nrm ls查看所有镜像地址</h4><pre class=" language-bash"><code class="language-bash">nrm <span class="token function">ls</span></code></pre><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><h4 id="安装成功后设置用户名邮箱"><a href="#安装成功后设置用户名邮箱" class="headerlink" title="安装成功后设置用户名邮箱"></a>安装成功后设置用户名邮箱</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> config --global user.name <span class="token string">"your name"</span><span class="token function">git</span> config --global user.email <span class="token string">"your email"</span></code></pre><h4 id="配置SSH-key"><a href="#配置SSH-key" class="headerlink" title="配置SSH key"></a>配置SSH key</h4><pre class=" language-bash"><code class="language-bash">ssh-keygen -t rsa -C <span class="token string">"邮件地址"</span>   // 生成key</code></pre><p>然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：</p><h4 id="验证是否成功"><a href="#验证是否成功" class="headerlink" title="验证是否成功"></a>验证是否成功</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">ssh</span> -T git@github.com <span class="token comment" spellcheck="true"># 注意邮箱地址不用改  //验证成功</span></code></pre><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><pre class=" language-bash"><code class="language-bash">    <span class="token function">npm</span> <span class="token function">install</span> -g hexo-cli</code></pre><h4 id="新建hexo工程：请执行下列命令，Hexo-将会在指定文件夹中新建所需要的文件"><a href="#新建hexo工程：请执行下列命令，Hexo-将会在指定文件夹中新建所需要的文件" class="headerlink" title="新建hexo工程：请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件"></a>新建hexo工程：请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件</h4><pre class=" language-bash"><code class="language-bash">$ hexo init <span class="token operator">&lt;</span>folder<span class="token operator">></span>$ <span class="token function">cd</span> <span class="token operator">&lt;</span>folder<span class="token operator">></span>$ <span class="token function">npm</span> <span class="token function">install</span></code></pre><h4 id="hexo本地部署"><a href="#hexo本地部署" class="headerlink" title="hexo本地部署"></a>hexo本地部署</h4><pre class=" language-bash"><code class="language-bash">    hexo clean  清理目录    hexo g 生成静态文件     hexo s 启动本地服务器     hexo d 发布到网站 （需要特殊配置）</code></pre><h3 id="静态网页部署至github"><a href="#静态网页部署至github" class="headerlink" title="静态网页部署至github"></a>静态网页部署至github</h3><h4 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h4><p>登陆自己的github 新建一个一个仓库 Repositories</p> <img src="/2020/04/06/hexo/1111.jpg" class=""><p>插入图片时由于官方插件有问题 这里用了别人改过的</p><pre><code>npm install https://github.com/7ym0n/hexo-asset-image --sa </code></pre><p>在Repositories name 输入 yourname.github.io,   yourname代表你自己github账号<br>待部署成功后可通过<a href="https://yourname.github.io" target="_blank" rel="noopener">https://yourname.github.io</a> 访问你部署的网站 </p><h4 id="配置git"><a href="#配置git" class="headerlink" title="配置git"></a>配置git</h4><h4 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save hexo-deployer-git</code></pre><h4 id="修改-config-yml文件"><a href="#修改-config-yml文件" class="headerlink" title="修改_config.yml文件"></a>修改_config.yml文件</h4><p>打开网站目录的 _config.yml<br>移动到最低端，在deploy:后面写入内容  注意空格很重要，刚开始忽略了空格出现了问题</p><pre><code>type: git    repo: github仓库地址      branch: master </code></pre><p>我的仓库地址    repo: <a href="mailto:git@github.com">git@github.com</a>:xiongb/xiongb.github.io.git</p><h4 id="最后通过hexo-d推送到github-可通过https-yourname-github-io访问了"><a href="#最后通过hexo-d推送到github-可通过https-yourname-github-io访问了" class="headerlink" title="最后通过hexo d推送到github   可通过https://yourname.github.io访问了"></a>最后通过hexo d推送到github   可通过<a href="https://yourname.github.io访问了" target="_blank" rel="noopener">https://yourname.github.io访问了</a></h4><pre class=" language-bash"><code class="language-bash">hexo d</code></pre><p> <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a><br> <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a><br> <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a><br> <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">github</a>.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Hexo 相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
